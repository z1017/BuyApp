# 前端Vue核心
开发一个前端模块可以概括为以下几个步骤： 
- （1）写静态页面、拆分为静态组件； 
- （2）发请求（API）； 
- （3）vuex（actions、mutations、state 三连操作）； 
- （4）组件获取仓库数据，动态展示；

# 1、vue文件目录分析
```
.文件目录
├── node_modules：项目依赖文件夹
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放公用的静态资源
│   │   └── logo.png
│   │── component: 非路由组件（全局组件），其他组件放在views或者pages文件夹中
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件 （唯一的根组件
│   └── main.js: 程序入口文件，最先执行的文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
└── package-lock.json: 包版本控制文件
```
# 2、项目配置
## 2.1 项目运行，浏览器自动打开
```json
package.json
    "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
    },
```
## 2.2 关闭 eslint 校验工具（不关闭会有各种规范，不按照规范就会报错）

根目录下创建 vue.config.js,进行配置
```js
module.exports = {
  //关闭eslint
  lintOnSave: false
  }
```
## 2.3 src 文件夹配置别名,创建 jsconfig.json，用 @/代替src/，exclude 表示不可以使用该别名的文件
```json
{
    "compilerOptions": {
        "baseUrl": "./",
            "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },

    "exclude": [
        "node_modules",
        "dist"
    ]
 }
 ```
 # 3、 项目路由的分析
- vue-router
- 前端所谓路由：KV键值对
- key: URL (地址栏中的路径)
- value：相应的路由组件
- 注意：项目上中下结构

路由组件：
Home 首页路由组件、Search 路由组件、login组件、Refister注册路由

非路由组件：
Header【 首页、搜索页 】
Footer【 首页、搜索页 】，但是在登录 / 注册页面没有

# 4、完成非路由组件Header与Footer业务
在开发项目的时候:
- 1:书写静态页面 (HTML + CSS)
- 2:拆分组件
- 3:获取服务器的数据动态展示
- 4:完成相应的动态业务逻辑
  
注意 1：创建组件的时候，组件结构 + 组件的样式 + 图片资源


组件页面的样式使用的是 less 样式，浏览器不识别该样式，需要下载相关依赖 ```npm install --save less less-loader@5``` 

如果想让组件识别 less 样式，则在组件中设置 ```<script scoped lang="less">```

## 4.1 使用组件的步骤(非路由组件)
- 创建或者定义
- 引入
- 注册
  
### 清除 vue 页面默认的样式
vue 是单页面开发，我们只需要修改 public 下的 index.html 文件
```<link rel="stylesheet" href="reset.css">```

# 5. 路由组件的搭建
vue-router  

在上面分析的时候，路由组件应该有四个: Home、Search、Login、Register

- components文件夹: 经常放置的非路由组件 (共用全局组件)
- pages/views文件夹: 经常放置路由组件
  
## 5.1 配置路由
项目当中配置的路由一般配置在router文件夹中

## 5.2 总结
路由组件和非路由组件区别：

- 非路由组件放在 components 中，路由组件放在 pages 或 views 中
- 非路由组件通过标签使用，路由组件通过路由使用（在 router 文件夹中进行注册（routes
- 在 main.js 注册完路由，所有的路由和非路由组件身上都会拥有 `$router`、`$route` 属性
- `$router`：一般进行**编程式导航进行路由跳转** 【push/replace】
- `$route`： 一般**获取路由信息**（name path params 等）

## 5.3 路由跳转方式

- 声明式导航 `router-link` 标签 ,可以把 router-link 理解为一个 `a 标签`，它也可以加 class 修饰
- 编程式导航 ：声明式导航能做的编程式都能做，而且还可以处理一些业务  

# 6. footer 组件显示与隐藏

- footer 在登录注册页面是不存在的，所以要隐藏，`v-if` 或者 `v-show`
- 这里使用 v-show，因为 v-if 会**频繁的操作 dom 元素消耗性能**，v-show 只是**通过样式**将元素显示或隐藏
- 配置路由的时候，可以给路由配置`元信息 meta`,
- 在路由的**元信息**中定义 show 属性，用来给 v-show 赋值，判断是否显示 footer 组件
  
# 7. 路由传参
路由跳转有几种方式  
> 声明式导航：router-link务必要有 to 属性)，可以实现路由的跳转

> 编程式导航：利用的是组件实例的$router.push | replace方法，可以实现路由的跳转，（可以书写一些自己的业务）

## 7.1 query、params

- query、params两个属性可以传递参数  
- `query` 参数：**不属于路径当中的一部分**，类似于 get 请求，地址栏表现为 `/search?k1=v1&k2=v2`   
  query 参数对应的路由信息 `path: "/search"`  

- `params` 参数：**属于路径当中的一部分**，需要注意，在配置路由的时候，***需要占位*** ,地址栏表现为 `/search/v1/v2`  
params 参数对应的路由信息要修改为 `path: "/search/:keyword"` 这里的 `/:keyword` 就是一个 **params 参数的占位符**
    
## 7.2 传参方法

- 字符串形式
```js
this.$router.push("/search/"+this.params传参+"?k="+this.query传参)
```
- 模板字符串
```js
this.router.push("/search/+{this.params传参}?k=${this.query传参}")
```
**注意：** 上面字符串的传参方法可以看出 params 参数和 `'/' `结合，query 参数和 `？`结合;  

`http://localhost:8080/#/search/asd?keyword=asd`  

上面 url 中 asd为 params 的值,`keyword=asd` 为 query 传递的值

- 对象（常用）  
  
```js
this.$router.push({name:"路由名字",params:{传参},query:{传参})
``` 
  以**对象方式**传参时，如果我们传参中使用了 params，只能使用name，不能使用 path，如果只是使用 query 传参，可以使用path

# 8. 多次执行相同的push问题
- 问题描述  
  编程式路由重复点击(参数不变),多次执行会抛出NavigationDuplicated警告报错

- 问题分析，为什么会报错？  
  Vue router3.1之后，`$router.push()`返回 Promise,返回的promise **没有设置**失败的**回调**，没有对错误进行处理

- 解决办法  
  1.对每个 `router.push()` 进行错误捕获
  ```
  router.push('xxxx').catch(err => {err})
  ```
  push方法还可以传入成功和失败的回调
  ```js
    this.$router.push({
		name:'search', // 路由记得命名
		params:{keyword:this.keyword},
		query:{keyword:this.keyword.toUpperCase()}
    },()=>{},(err)=>{if(如果是NavigationDuplicated错误)console.log(err)})

  ```


- 方法：
```js
this.$router.push({name:'Search',params:{keyword:".."||undefined}},()=>{},()=>{}) 
```
后面两项分别代表 **执行成功和失败的回调函数**。  
但是这种写法治标不治本，将来在别的组件中 `push|replace`,编程式导航还是会有类似错误。  
- push 是 `VueRouter.prototype` 的一个方法，在 router 中的 `index` **重写该方法即可**

- 2.重写 push() 方法  
  ① 先保存 VueRouter 原型上的 push 方法  
  ② 重写 push|repalce  
  
```js
// 1、先把 VueRouter 原型对象的 push，保存一份
let originPush = VueRouter.prototype.push;

// 2、重写 push|replace
// 第一个参数：告诉原来的 push，跳转的目标位置和传递了哪些参数
VueRouter.prototype.push = function (location,resolve,reject){
    if(resolve && reject){
        originPush.call(this,location,resolve,reject)
    }else{
        originPush.call(this,location,() => {},() => {})
    }
}
```

# 9. 三级联动
我们的三级联动组件是全局组件，全局的配置都需要在 main.js 中配置

```js
//将三级联动组件注册为全局组件
import TypeNav from '@/pages/Home/TypeNav';
//第一个参数：全局组件名字，第二个参数：全局组件
Vue.component(TypeNav.name,TypeNav);
```
在 Home 组件中使用该全局组件

```Vue
<template>
<div>
<!--  三级联动全局组件已经注册为全局组件，因此不需要引入-->
  <TypeNav/>
</div>
</template>
```
全局组件可以在任一页面中直接使用，不需要导入声明

# 10. 对 axios 进行二次封装
> 向服务器发请求的几种方法：XMLHttpRequest、fetch、JQ、axios( 常用 )

封装的目的

- 请求拦截器：设置**发送请求前**的统一操作
- 响应拦截器：**请求响应后**进行统一操作
 
- 对不同的需求(请求前缀)创建不同的 axios 请求实例
  - api 请求(从**后台**获取数据), '/api' 开头的前缀
  - mock 请求( mockjs 模拟的数据), /mock 开头的前缀

进行了哪些封装？  

请求拦截器
- 请求头中添加 token 给服务器
- 设置请求超时时间  
  
响应拦截器
- 请求成功直接获取 res.data ，请求失败终止 promise 链
- 无权限处理，主动刷新 token

> axios 中文文档，包含详细信息。 https://www.kancloud.cn/yunye/axios/234845  

在根目录下创建 api 文件夹，创建 request.js 文件。 内容如下，当前文件代码还比较少，后续有需求可以增添内容。
```js
// 对于axios 进行二次封装
import axios from "axios";

// 1. 利用 axios 对象的方法create，去创建一个 axios 实例
// 2. request 就是 axios, 只不过稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发送请求的时候，路径当中会出现api
    baseURL: "/api",
    // 代表请求请求超时的时间 5s
    timeout: 5000,
})

// 请求拦截器：再发请求之前。请求拦截器可以检测到，可以在请求发出去之前做一些事情

requests.interceptors.request.use((config) => {
    // config: 配置对象，对象里面有一个属性很重要：headers请求头
    // config内主要是对请求头 Header 配置
    // 比如添加 token
    return config
});

// 响应拦截器
requests.interceptors.response.use((res) => {
    // 成功的回调函数：服务器响应数据回来以后，相应拦截器可以检测到，可以做一些事情
    return res.data

    // eslint-disable-next-line no-unused-vars
}, (error) => {
    // 响应失败的回调函数
    return Promise.reject(new Error('fail'));
})

// 对外暴露
export default requests;
```

# 11. 请求接口统一封装
在文件夹 api 中创建 index.js 文件，用于封装所有请求 **将每个请求封装为一个函数，并暴露出去，组件只需要调用相应函数即可，这样当我们的接口比较多时，如果需要修改只需要修改该文件即可**
如下所示：
```js
//当前模块，API进行统一管理，即对请求接口统一管理
import requests from "@/api/request";

//首页三级分类接口
export const reqCateGoryList = () => {
    return  requests({
        url: '/product/getBaseCategoryList',
        method: 'GET'
    })
}
```
当组件想要使用相关请求时，只需要导入相关函数即可，以上方的reqCateGoryList 为例：
```js
import {reqCateGoryList} from './api'
//发起请求
reqCateGoryList();
```

# 12. nprogress 进度条插件
打开一个页面时，往往会伴随一些请求，并且会在页面上方出现进度条。例如页面加载时发起了一个请求，此时页面上方出现蓝色进度条  
它的原理是：在我们**发起请求时开启进度条**，在**请求成功后关闭进度条**，所以只需要在 request.js 中进行配置。   
```js
// 对于axios 进行二次封装
import axios from "axios";
// 引入进度条
import nprogress from "nprogress";
// start:进度条开始  done:进度条结束

// 引入进度条样式
import 'nprogress/nprogress.css'

const requests = axios.create({
    baseURL: "/api",
    timeout: 5000,
})

// 请求拦截器：在发请求之前。请求拦截器可以检测到，可以在请求发出去之前做一些事情
requests.interceptors.request.use((config) => {
    // 进度条开始
    nprogress.start();
    return config
});

// 响应拦截器
requests.interceptors.response.use((res) => {
    // 成功的回调函数：服务器响应数据回来以后，相应拦截器可以检测到，可以做一些事情

    // 进度条结束
    nprogress.done()
    return res.data
}, (error) => {
    // 响应失败的回调函数
    return Promise.reject(new Error('fail'));
})
// 对外暴露
export default requests;
```
可以通过修改 nprogress.css 文件的 background 来修改进度条颜色。 

# 13. 手动引入 vuex
vuex是 专门在  Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 Vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信

> 笔记参考：https://www.yuque.com/qingzhou-d07dz/exgbtr/gdnxc0qvktqvpe8i  

首先确保安装了 vuex ,根目录创建 store 文件夹，文件夹下创建 index.js ，内容如下：
```js
import Vue from "vue";
import Vuex from 'vuex' // 引入Vuex

Vue.use(Vuex) // 应用 Vuex插件

// state: 仓库存储数据的地方
const state = {};
// mutations: 修改state的唯一手段
const mutations = {};
// actions: 处理action，可以书写自己的业务逻辑，也可以处理异步
const actions = {};
// getters: 当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工，相当于全局计算属性,用于简化仓库，让组件获取仓库的数据更加方便
const getters = {}

// 创建并对外暴露Store类的一个实例
export default new Vuex.Store({
    state,
    mutations,
    actions,
    getters
})
```
如果想要使用 vuex，还要在 main.js 中引入  
- (1) 引入文件   
- (2) 注册 store， 但凡是在 main.js 中的 Vue 实例中注册的实体，在所有的组件中都会有（`this.$.实体名`）属性
  
```js
import store from './store'
new Vue({
  render: h => h(App),
  //注册路由，此时组件中都会拥有$router $route属性
  router,
  //注册store,此时组件中都会拥有$store
  store
}).$mount('#app')
```
# 14. async await使用

如果我们没有封装请求 api，而是直接调用 axios，就不需要使用 async await。   
案例：我们将一个 axios 请求封装为了函数，我们在下面代码中调用了该函数：  
```js
import {reqCateGoryList} from '@/api'
export default {
    actions:{
        categoryList(){
            let result =  reqCateGoryList()
            console.log(result)
        }
    }
}
```
返回了一个 promise,证明这是一个 promise 请求，但是我们想要的是的 data 数据。 没有将函数封装前我们都会通过 then()回调函数 拿到服务器返回的数据，现在我们将其封装了，依然可以使用 then 获取数据，代码如下:
```js
actions:{
        categoryList(){
            let result =  reqCateGoryList().then(
                res=>{
                console.log("res")
                console.log(res)
                return res
                }
            )
            console.log("result")
            console.log(result)
        }
    }
```
由于我们的 promis 是**异步请求**，我们发现请求需要花费时间，但它是异步的，所以后面的 `console.log("result")`；`console.log(result)`会先执行，等我们的请求得到响应后，才执行 `console.log("res")`；`console.log(res)`，这也符合异步的原则，但是如果在请求下面执行**将请求的结果赋值给某个变量**，这样就会导致被赋值的变量先执行，并且赋值为 undefine，因为此时 promise 还没有完成。 

所以我们引入了 `async 、await`  ：
  
async 写在函数名前，await 写在 api 函数前。  
await 含义是 async 标识的函数体 并且在 await 标识代码后面的代码先等待 **await标识的异步请求执行完**，再执行。这也使得只有reqCateGoryList 执行完，result 得到返回值后，才会执行后面的输出操作。
```js
   async categoryList(){
            let result = await reqCateGoryList()
            console.log("result")
            console.log(result)
        }
```
# 15. 编程式导航 + 事件委托实现路由跳转

三级标签列表有很多，每一个标签都是一个页面链接，我们要实现通过点击表现进行路由跳转。   
路由跳转的两种方法：1. 导航式路由，2. 编程式路由。

> 对于导航式路由，我们有多少个 a 标签就会生成多少个 router-link 标签，这样当我们频繁操作时会出现卡顿现象。   
> 对于编程式路由，我们是通过**触发点击事件实现路由跳转**。同理有多少个 a 标签就会有多少个触发函数。虽然不会出现卡顿，但是也会影响性能。

上面两种方法无论采用哪一种，都会影响性能。我们提出一种：`编程式导航 + 事件委派` 的方式实现路由跳转。  
事件委派即把子节点的触发事件都委托给父节点。这样只需要一个回调函数 goSearch 就可以解决。

**事件委派问题**： （1）如何确定我们点击的一定是 a 标签呢？如何保证我们只能通过点击 a 标签才跳转呢？ （2）如何获取子节点标签的商品名称和商品 id ( 我们是通过商品名称和商品 id 进行页面跳转的 )
### 解决方法： 
对于问题 (1)：为三个等级的 a 标签添加自定义属性  `date-categoryName` 绑定商品标签名称来标识 a 标签（其余的标签是没有该属性的）。

对于问题 (2)：为三个等级的 a 标签再添加自定义属性  `data-category1Id`、`data-category2Id`、`data-category3Id`来获取三个等级 a 标签的商品 id，用于路由跳转。 我们可以通过在函数中传入 event 参数，获取当前的点击事件，通过 `event.target` 属性获取当前点击节点，再通过 `dataset` 属性获取节点的属性信息。

```html
 <div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex">
          <div class="item"  v-for="(c1,index) in categoryList" v-show="index!==16" :key="c1.categoryId" :class="{cur:currentIndex===index}">
            <h3 @mouseenter="changeIndex(index)"  >
              <a :data-categoryName="c1.categoryName" :data-category1Id="c1.categoryId" >{{c1.categoryName}}</a>
            </h3>
            <div class="item-list clearfix" :style="{display:currentIndex===index?'block':'none'}">
              <div class="subitem" v-for="(c2,index) in c1.categoryChild" :key="c2.categoryId">
                <dl class="fore">
                  <dt>
                    <a :data-categoryName="c2.categoryName" :data-category2Id="c2.categoryId">{{c2.categoryName}}</a>
                  </dt>
                  <dd>
                    <em v-for="(c3,index) in c2.categoryChild"  :key="c3.categoryId">
                      <a :data-categoryName="c2.categoryName" :data-category3Id="c3.categoryId">{{c3.categoryName}}</a>
                    </em>
</dd></dl></div></div></div></div>
```
注意：event 是系统属性，所以我们只需要在函数定义的时候作为参数传入，在函数使用的时候不需要传入该参数。
```js
//函数使用
<div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex">
//函数定义
goSearch(event){
      console.log(event.target)
    }
```
对应的goSearrch函数
```js
goSearch(event){
      let element = event.target
      //html中会把大写转为小写
      //获取目前鼠标点击标签的categoryname,category1id,category2id,category3id，
      // 通过四个属性是否存在来判断是否为a标签，以及属于哪一个等级的a标签
      let {categoryname,category1id,category2id,category3id} = element.dataset


      //categoryname存在，表示为a标签
      if(categoryname){
        //category1id一级a标签
        //整理路由跳转的参数
        let location = {name:'Search'}//跳转路由name
        let query = {categoryName:categoryname}//路由参数

        if(category1id){
          query.category1Id = category1id
        }else if(category2id){
        //category2id二级a标签
          query.category2Id = category2id
        }else if(category3id){
        //category3id三级a标签
          query.category3Id = category3id
        }
        //整理完参数
        location.query = query
        //路由跳转
        this.$router.push(location)

      }
    },
```
# 16. Vue 路由销毁问题
> Vue 在路由切换的时候会销毁旧路由。 我们在三级列表全局组件TypeNav中的mounted进行了请求一次商品分类列表数据。 由于Vue在路由切换的时候会销毁旧路由，当我们再次使用三级列表全局组件时还会发一次请求。 如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求。 在这里插入图片描述 由于信息都是一样的，出于性能的考虑我们希望该数据只请求一次，所以我们把这次请求放在App.vue的mounted中。（根组件App.vue的mounted只会执行一次） 注意：虽然main.js也是只执行一次，但是不可以放在main.js中。因为只有组件的身上才会有$store属性。

# 17. mock 插件使用
mockjs 生成随机数据，当前端使用 mock 模拟的数据接口时，mockjs进行数据返回，并拦截 ajax 请求不发送给后台。     
使用步骤：  
- 1.在src下创建mock文件夹
- 2.准备JSON数据（mock文件夹中创建相应的JSON文件）
- 3.需要将相关的图片拷贝到 public/images目录下
- 4.创建mock.js，通过mockjs插件实现模拟数据
- 5.mockServe.js文件在入口文件中引入（至少需要执行一次，才能模拟数据）
  
封装一个 mock 请求的 axios
```js
const mockRequests = axios.create({
    baseURL:"/mock",
    timeout:5000, //请求超时的时间5s
})

//请求拦截器
mockRequests.interceptors.request.use((config)=>{
    //config:配置对象，对象里面有一个属性很重要，header请求头
    nprogress.start();//进度条开始
    return config;
})

//响应拦截器
//参数1成功的回调，参数2失败的回调
mockRequests.interceptors.response.use((res)=>{
    nprogress.done();//进度条结束
   return res.data;//返回服务器返回的数据

},(error)=>{
    return Promise.reject(new Error('fail')) //终止promise链
})

export default mockRequests;

//采用mock发送请求
import mockRequests from "./request";
//获取Home首页轮播图banner的结构
export const getBannerList = () => mockRequests.get('/banner');
```

# 18. vuex 数据存储与使用
我们会把公共的数据放在 store 中，然后使用时再去 store 中取。 以我们的首页轮播图数据为例。 

1、在轮播图组件 ListContainer.vue 组件加载完毕后发起轮播图数据请求。

 ```js
 mounted() {
    this.$store.dispatch("getBannerList")
  },
```
2、请求实际是在 store 中的 actions 中完成的

```js
actions:{
        //获取首页轮播图数据
        async getBannerList({commit}){
            let result = await reqGetBannerList()
            if(result.code ===  200){
                commit("BANNERLIST",result.data)
            }
        }
    }
```
3、获取到数据后存入 store 仓库，在 mutations 完成

```js
// 唯一修改 state 的部分
    mutations:{
        BANNERLIST(state,bannerList){
            state.bannerList = bannerList
        }
    },
```
4、轮播图组件 ListContainer.vue 组件在 store 中获取轮播图数据。由于在这个数据是通过异步请求获得的，所以我们要通过计算属性computed 获取轮播图数据。

ListContainer.vue代码

```js
import {mapState} from "vuex";
export default {
  name: "index",
  //主键挂载完毕，请求轮播图图片
  mounted() {
    this.$store.dispatch("getBannerList")
  },
  computed:{
    ...mapState({
      bannerList: (state => state.home.bannerList)
    })
  }
}
```
总结：只要是公共数据都会放在 store 中，之后的实现步骤就是上面的固定步骤。

# 19. swiper 插件实现轮播图

官网中给出了代码实例：
 
（1）安装 swiper   
（2）在需要**使用轮播图的组件内**导入 swpier 和它的 css 样式   
（3）在组件中创建 swiper 需要的 dom 标签（ html代码，参考官网代码 ）    
（4）创建 swiper 实例  

注意：在创建 swiper对象时，我们会传递一个参数用于获取展示轮播图的 DOM元素，官网直接通过 class（而且这个 class 不能修改，是 swiper 的 css文件自带的）获取。  
但是这样有*缺点*：当页面中有多个轮播图时，因为它们使用了相同的 class修饰的 DOM，就会出现所有的 swiper 使用同样的数据，这肯定不是我们希望看到的。   
解决方法：在轮播图**最外层 DOM 中添加 ref 属性**

`<div class="swiper-container" id="mySwiper" ref="cur"> 通过ref属性值获取DOM let mySwiper = new Swiper(this.$refs.cur,{...})`

```js
 <!--banner轮播-->
        <div class="swiper-container" id="mySwiper" ref="cur">

          <div class="swiper-wrapper">
            <div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id">
              <img :src="carouse.imgUrl" />
            </div>
          </div>

          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev" ></div>
          <div class="swiper-button-next"></div>
        </div>
<script>
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'
</script>
```

接下来要考虑的是什么时候去加载这个 swiper，我们第一时间想到的是在mounted 中创建这个实例。 但是会出现**无法加载轮播图片的问题**。  

### 原因：
> 我们在 mounted 中先去异步请求了轮播图数据，然后又创建的 swiper 实例。由于请求数据是异步的，所以浏览器不会等待该请求执行完再去创建swiper，而是先创建了 swiper实例，但是此时我们的轮播图数据还没有获得，就导致了轮播图展示失败。

```js
mounted() {
	//请求数据
    this.$store.dispatch("getBannerList")
    //创建swiper实例
    let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
      })
  },
```
解决方法一：等我们的数据请求完毕后再创建 swiper 实例。只需要加一个1000ms时间延迟再创建 swiper实例。将上面代码改为：  
```js
mounted() {
    this.$store.dispatch("getBannerList")
    setTimeout(()=>{
      let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
      })
    },1000)
  },
```
方法一肯定不是最好的，但是我们开发的第一要义就是实现功能，之后再完善。  

解决方法二：我们可以使用 watch 监听 bannerList 轮播图列表属性，因为 bannerList 初始值为空，当它有数据时，我们就可以创建 swiper 对象
```js
watch:{
    bannerList(newValue,oldValue){
        let mySwiper = new Swiper(this.$refs.cur,{
          pagination:{
            el: '.swiper-pagination',
            clickable: true,
          },
          // 如果需要前进后退按钮
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
          // 如果需要滚动条
          scrollbar: {
            el: '.swiper-scrollbar',
          },
        })
    }
  }
```
即使这样也还是无法实现轮播图，原因是，我们轮播图的 html 中有 v-for 的循环，我们是通过 v-for 遍历 bannerList 中的图片数据，然后展示。我们的 watch只能保证在 bannerList 变化时创建 swiper 对象，但是并不能保证此时 v-for 已经执行完了。假如 watch 先监听到 bannerList 数据变化，执行回调函数创建了swiper 对象，之后 v-for 才执行，这样也是无法渲染轮播图图片（因为 swiper 对象生效的前提是 html, 即 dom 结构已经渲染好了）。

**完美解决方案**：使用 watch + this.$nextTick()   
官方介绍：`this. $nextTick` 它会将回调延迟到下次 DOM更新 循环结束 之后执行（循环就是这里的 v-for）。 个人理解：无非是等我们页面中的结构都有了再去执行回调函数

完整代码
```js
<template>
  <!--列表-->
  <div class="list-container">
    <div class="sortList clearfix">
      <div class="center">
        <!--banner轮播-->
        <div class="swiper-container" id="mySwiper">

          <div class="swiper-wrapper">
            <div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id">
              <img :src="carouse.imgUrl" />
            </div>
          </div>

          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev" ></div>
          <div class="swiper-button-next"></div>
        </div>
      </div>
      </div>
    </div>
  </div>
</template>
<script>
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'

import {mapState} from "vuex";

export default {
  name: "index",
  //主键挂载完毕，ajax请求轮播图图片
  mounted() {
    this.$store.dispatch("getBannerList")
  },
  computed:{
    ...mapState({
    //从仓库中获取轮播图数据
      bannerList: (state) => {return state.home.bannerList}
    })
  },
  watch:{
    bannerList(newValue,oldValue){
        //this.$nextTick()使用
        this.$nextTick(()=>{
          let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
            pagination:{
              el: '.swiper-pagination',
              clickable: true,
            },
            // 如果需要前进后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev',
            },
            // 如果需要滚动条
            scrollbar: {
              el: '.swiper-scrollbar',
            },
          })
        })
    }
  }
}
</script>
```
注意：之前我们在学习watch时，一般都是监听定义在data中的属性，但是我们这里是监听的是computed中的属性，这样也是完全可以的，并且如果你的业务数据也是从store中通过computed动态获取的，也需要watch监听数据变化执行相应回调函数，完全可以模仿上面的写法。