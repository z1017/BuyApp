# 前端Vue核心
开发一个前端模块可以概括为以下几个步骤： 
- （1）写静态页面、拆分为静态组件； 
- （2）发请求（API）； 
- （3）vuex（actions、mutations、state 三连操作）； 
- （4）组件获取仓库数据，动态展示；

# 1、vue文件目录分析
```
.文件目录
├── node_modules：项目依赖文件夹
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放公用的静态资源
│   │   └── logo.png
│   │── component: 非路由组件（全局组件），其他组件放在views或者pages文件夹中
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件 （唯一的根组件
│   └── main.js: 程序入口文件，最先执行的文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
└── package-lock.json: 包版本控制文件
```
# 2、项目配置
## 2.1 项目运行，浏览器自动打开
```json
package.json
    "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
    },
```
## 2.2 关闭 eslint 校验工具（不关闭会有各种规范，不按照规范就会报错）

根目录下创建 vue.config.js,进行配置
```js
module.exports = {
  //关闭eslint
  lintOnSave: false
  }
```
## 2.3 src 文件夹配置别名,创建 jsconfig.json，用 @/代替src/，exclude 表示不可以使用该别名的文件
```json
{
    "compilerOptions": {
        "baseUrl": "./",
            "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },

    "exclude": [
        "node_modules",
        "dist"
    ]
 }
 ```
 # 3、 项目路由的分析
- vue-router
- 前端所谓路由：KV键值对
- key: URL (地址栏中的路径)
- value：相应的路由组件
- 注意：项目上中下结构

路由组件：
Home 首页路由组件、Search 路由组件、login组件、Refister注册路由

非路由组件：
Header【 首页、搜索页 】
Footer【 首页、搜索页 】，但是在登录 / 注册页面没有

# 4、完成非路由组件Header与Footer业务
在开发项目的时候:
- 1:书写静态页面 (HTML + CSS)
- 2:拆分组件
- 3:获取服务器的数据动态展示
- 4:完成相应的动态业务逻辑
  
注意 1：创建组件的时候，组件结构 + 组件的样式 + 图片资源


组件页面的样式使用的是 less 样式，浏览器不识别该样式，需要下载相关依赖 ```npm install --save less less-loader@5``` 

如果想让组件识别 less 样式，则在组件中设置 ```<script scoped lang="less">```

## 4.1 使用组件的步骤(非路由组件)
- 创建或者定义
- 引入
- 注册
  
### 清除 vue 页面默认的样式
vue 是单页面开发，我们只需要修改 public 下的 index.html 文件
```<link rel="stylesheet" href="reset.css">```

# 5. 路由组件的搭建
vue-router  

在上面分析的时候，路由组件应该有四个: Home、Search、Login、Register

- components文件夹: 经常放置的非路由组件 (共用全局组件)
- pages/views文件夹: 经常放置路由组件
  
## 5.1 配置路由
项目当中配置的路由一般配置在router文件夹中

## 5.2 总结
路由组件和非路由组件区别：

- 非路由组件放在 components 中，路由组件放在 pages 或 views 中
- 非路由组件通过标签使用，路由组件通过路由使用（在 router 文件夹中进行注册（routes
- 在 main.js 注册完路由，所有的路由和非路由组件身上都会拥有 `$router`、`$route` 属性
- `$router`：一般进行**编程式导航进行路由跳转** 【push/replace】
- `$route`： 一般**获取路由信息**（name path params 等）

## 5.3 路由跳转方式

- 声明式导航 `router-link` 标签 ,可以把 router-link 理解为一个 `a 标签`，它也可以加 class 修饰
- 编程式导航 ：声明式导航能做的编程式都能做，而且还可以处理一些业务  

# 6. footer 组件显示与隐藏

- footer 在登录注册页面是不存在的，所以要隐藏，`v-if` 或者 `v-show`
- 这里使用 v-show，因为 v-if 会**频繁的操作 dom 元素消耗性能**，v-show 只是**通过样式**将元素显示或隐藏
- 配置路由的时候，可以给路由配置`元信息 meta`,
- 在路由的**元信息**中定义 show 属性，用来给 v-show 赋值，判断是否显示 footer 组件
  
# 7. 路由传参
路由跳转有几种方式  
> 声明式导航：router-link务必要有 to 属性)，可以实现路由的跳转

> 编程式导航：利用的是组件实例的$router.push | replace方法，可以实现路由的跳转，（可以书写一些自己的业务）

## 7.1 query、params

- query、params两个属性可以传递参数  
- `query` 参数：**不属于路径当中的一部分**，类似于 get 请求，地址栏表现为 `/search?k1=v1&k2=v2`   
  query 参数对应的路由信息 `path: "/search"`  

- `params` 参数：**属于路径当中的一部分**，需要注意，在配置路由的时候，***需要占位*** ,地址栏表现为 `/search/v1/v2`  
params 参数对应的路由信息要修改为 `path: "/search/:keyword"` 这里的 `/:keyword` 就是一个 **params 参数的占位符**
    
## 7.2 传参方法

- 字符串形式
```js
this.$router.push("/search/"+this.params传参+"?k="+this.query传参)
```
- 模板字符串
```js
this.router.push("/search/+{this.params传参}?k=${this.query传参}")
```
**注意：** 上面字符串的传参方法可以看出 params 参数和 `'/' `结合，query 参数和 `？`结合;  

`http://localhost:8080/#/search/asd?keyword=asd`  

上面 url 中 asd为 params 的值,`keyword=asd` 为 query 传递的值

- 对象（常用）  
  
```js
this.$router.push({name:"路由名字",params:{传参},query:{传参})
``` 
  以**对象方式**传参时，如果我们传参中使用了 params，只能使用name，不能使用 path，如果只是使用 query 传参，可以使用path

# 8. 多次执行相同的push问题
- 问题描述  
  编程式路由重复点击(参数不变),多次执行会抛出NavigationDuplicated警告报错

- 问题分析，为什么会报错？  
  Vue router3.1之后，`$router.push()`返回 Promise,返回的promise **没有设置**失败的**回调**，没有对错误进行处理

- 解决办法  
  1.对每个 `router.push()` 进行错误捕获
  ```
  router.push('xxxx').catch(err => {err})
  ```
  push方法还可以传入成功和失败的回调
  ```js
    this.$router.push({
		name:'search', // 路由记得命名
		params:{keyword:this.keyword},
		query:{keyword:this.keyword.toUpperCase()}
    },()=>{},(err)=>{if(如果是NavigationDuplicated错误)console.log(err)})

  ```


- 方法：
```js
this.$router.push({name:'Search',params:{keyword:".."||undefined}},()=>{},()=>{}) 
```
后面两项分别代表 **执行成功和失败的回调函数**。  
但是这种写法治标不治本，将来在别的组件中 `push|replace`,编程式导航还是会有类似错误。  
- push 是 `VueRouter.prototype` 的一个方法，在 router 中的 `index` **重写该方法即可**

- 2.重写 push() 方法  
  ① 先保存 VueRouter 原型上的 push 方法  
  ② 重写 push|repalce  
  
```js
// 1、先把 VueRouter 原型对象的 push，保存一份
let originPush = VueRouter.prototype.push;

// 2、重写 push|replace
// 第一个参数：告诉原来的 push，跳转的目标位置和传递了哪些参数
VueRouter.prototype.push = function (location,resolve,reject){
    if(resolve && reject){
        originPush.call(this,location,resolve,reject)
    }else{
        originPush.call(this,location,() => {},() => {})
    }
}
```

# 9. 三级联动
我们的三级联动组件是全局组件，全局的配置都需要在 main.js 中配置

```js
//将三级联动组件注册为全局组件
import TypeNav from '@/pages/Home/TypeNav';
//第一个参数：全局组件名字，第二个参数：全局组件
Vue.component(TypeNav.name,TypeNav);
```
在 Home 组件中使用该全局组件

```Vue
<template>
<div>
<!--  三级联动全局组件已经注册为全局组件，因此不需要引入-->
  <TypeNav/>
</div>
</template>
```
全局组件可以在任一页面中直接使用，不需要导入声明

# 10. 对 axios 进行二次封装
> 向服务器发请求的几种方法：XMLHttpRequest、fetch、JQ、axios( 常用 )

封装的目的

- 请求拦截器：设置**发送请求前**的统一操作
- 响应拦截器：**请求响应后**进行统一操作
 
- 对不同的需求(请求前缀)创建不同的 axios 请求实例
  - api 请求(从**后台**获取数据), '/api' 开头的前缀
  - mock 请求( mockjs 模拟的数据), /mock 开头的前缀

进行了哪些封装？  

请求拦截器
- 请求头中添加 token 给服务器
- 设置请求超时时间  
  
响应拦截器
- 请求成功直接获取 res.data ，请求失败终止 promise 链
- 无权限处理，主动刷新 token

> axios 中文文档，包含详细信息。 https://www.kancloud.cn/yunye/axios/234845  

在根目录下创建 api 文件夹，创建 request.js 文件。 内容如下，当前文件代码还比较少，后续有需求可以增添内容。
```js
// 对于axios 进行二次封装
import axios from "axios";

// 1. 利用 axios 对象的方法create，去创建一个 axios 实例
// 2. request 就是 axios, 只不过稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发送请求的时候，路径当中会出现api
    baseURL: "/api",
    // 代表请求请求超时的时间 5s
    timeout: 5000,
})

// 请求拦截器：再发请求之前。请求拦截器可以检测到，可以在请求发出去之前做一些事情

requests.interceptors.request.use((config) => {
    // config: 配置对象，对象里面有一个属性很重要：headers请求头
    // config内主要是对请求头 Header 配置
    // 比如添加 token
    return config
});

// 响应拦截器
requests.interceptors.response.use((res) => {
    // 成功的回调函数：服务器响应数据回来以后，相应拦截器可以检测到，可以做一些事情
    return res.data

    // eslint-disable-next-line no-unused-vars
}, (error) => {
    // 响应失败的回调函数
    return Promise.reject(new Error('fail'));
})

// 对外暴露
export default requests;
```

# 11. 请求接口统一封装
在文件夹 api 中创建 index.js 文件，用于封装所有请求 **将每个请求封装为一个函数，并暴露出去，组件只需要调用相应函数即可，这样当我们的接口比较多时，如果需要修改只需要修改该文件即可**
如下所示：
```js
//当前模块，API进行统一管理，即对请求接口统一管理
import requests from "@/api/request";

//首页三级分类接口
export const reqCateGoryList = () => {
    return  requests({
        url: '/product/getBaseCategoryList',
        method: 'GET'
    })
}
```
当组件想要使用相关请求时，只需要导入相关函数即可，以上方的reqCateGoryList 为例：
```js
import {reqCateGoryList} from './api'
//发起请求
reqCateGoryList();
```

# 12. nprogress 进度条插件
打开一个页面时，往往会伴随一些请求，并且会在页面上方出现进度条。例如页面加载时发起了一个请求，此时页面上方出现蓝色进度条  
它的原理是：在我们**发起请求时开启进度条**，在**请求成功后关闭进度条**，所以只需要在 request.js 中进行配置。   
```js
// 对于axios 进行二次封装
import axios from "axios";
// 引入进度条
import nprogress from "nprogress";
// start:进度条开始  done:进度条结束

// 引入进度条样式
import 'nprogress/nprogress.css'

const requests = axios.create({
    baseURL: "/api",
    timeout: 5000,
})

// 请求拦截器：在发请求之前。请求拦截器可以检测到，可以在请求发出去之前做一些事情
requests.interceptors.request.use((config) => {
    // 进度条开始
    nprogress.start();
    return config
});

// 响应拦截器
requests.interceptors.response.use((res) => {
    // 成功的回调函数：服务器响应数据回来以后，相应拦截器可以检测到，可以做一些事情

    // 进度条结束
    nprogress.done()
    return res.data
}, (error) => {
    // 响应失败的回调函数
    return Promise.reject(new Error('fail'));
})
// 对外暴露
export default requests;
```
可以通过修改 nprogress.css 文件的 background 来修改进度条颜色。 

# 13. 手动引入 vuex
vuex是 专门在  Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 Vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信

> 笔记参考：https://www.yuque.com/qingzhou-d07dz/exgbtr/gdnxc0qvktqvpe8i  

首先确保安装了 vuex ,根目录创建 store 文件夹，文件夹下创建 index.js ，内容如下：
```js
import Vue from "vue";
import Vuex from 'vuex' // 引入Vuex

Vue.use(Vuex) // 应用 Vuex插件

// state: 仓库存储数据的地方
const state = {};
// mutations: 修改state的唯一手段
const mutations = {};
// actions: 处理action，可以书写自己的业务逻辑，也可以处理异步
const actions = {};
// getters: 当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工，相当于全局计算属性,用于简化仓库，让组件获取仓库的数据更加方便
const getters = {}

// 创建并对外暴露Store类的一个实例
export default new Vuex.Store({
    state,
    mutations,
    actions,
    getters
})
```
如果想要使用 vuex，还要在 main.js 中引入  
- (1) 引入文件   
- (2) 注册 store， 但凡是在 main.js 中的 Vue 实例中注册的实体，在所有的组件中都会有（`this.$.实体名`）属性
  
```js
import store from './store'
new Vue({
  render: h => h(App),
  //注册路由，此时组件中都会拥有$router $route属性
  router,
  //注册store,此时组件中都会拥有$store
  store
}).$mount('#app')
```
# 14. async await使用

如果我们没有封装请求 api，而是直接调用 axios，就不需要使用 async await。   
案例：我们将一个 axios 请求封装为了函数，我们在下面代码中调用了该函数：  
```js
import {reqCateGoryList} from '@/api'
export default {
    actions:{
        categoryList(){
            let result =  reqCateGoryList()
            console.log(result)
        }
    }
}
```
返回了一个 promise,证明这是一个 promise 请求，但是我们想要的是的 data 数据。 没有将函数封装前我们都会通过 then()回调函数 拿到服务器返回的数据，现在我们将其封装了，依然可以使用 then 获取数据，代码如下:
```js
actions:{
        categoryList(){
            let result =  reqCateGoryList().then(
                res=>{
                console.log("res")
                console.log(res)
                return res
                }
            )
            console.log("result")
            console.log(result)
        }
    }
```
由于我们的 promis 是**异步请求**，我们发现请求需要花费时间，但它是异步的，所以后面的 `console.log("result")`；`console.log(result)`会先执行，等我们的请求得到响应后，才执行 `console.log("res")`；`console.log(res)`，这也符合异步的原则，但是如果在请求下面执行**将请求的结果赋值给某个变量**，这样就会导致被赋值的变量先执行，并且赋值为 undefine，因为此时 promise 还没有完成。 

所以我们引入了 `async 、await`  ：
  
async 写在函数名前，await 写在 api 函数前。  
await 含义是 async 标识的函数体 并且在 await 标识代码后面的代码先等待 **await标识的异步请求执行完**，再执行。这也使得只有reqCateGoryList 执行完，result 得到返回值后，才会执行后面的输出操作。
```js
   async categoryList(){
            let result = await reqCateGoryList()
            console.log("result")
            console.log(result)
        }
```
# 15. 编程式导航 + 事件委托实现路由跳转

三级标签列表有很多，每一个标签都是一个页面链接，我们要实现通过点击表现进行路由跳转。   
路由跳转的两种方法：1. 导航式路由，2. 编程式路由。

> 对于导航式路由，我们有多少个 a 标签就会生成多少个 router-link 标签，这样当我们频繁操作时会出现卡顿现象。   
> 对于编程式路由，我们是通过**触发点击事件实现路由跳转**。同理有多少个 a 标签就会有多少个触发函数。虽然不会出现卡顿，但是也会影响性能。

上面两种方法无论采用哪一种，都会影响性能。我们提出一种：`编程式导航 + 事件委派` 的方式实现路由跳转。  
事件委派即把子节点的触发事件都委托给父节点。这样只需要一个回调函数 goSearch 就可以解决。

**事件委派问题**： （1）如何确定我们点击的一定是 a 标签呢？如何保证我们只能通过点击 a 标签才跳转呢？ （2）如何获取子节点标签的商品名称和商品 id ( 我们是通过商品名称和商品 id 进行页面跳转的 )
### 解决方法： 
对于问题 (1)：为三个等级的 a 标签添加自定义属性  `date-categoryName` 绑定商品标签名称来标识 a 标签（其余的标签是没有该属性的）。

对于问题 (2)：为三个等级的 a 标签再添加自定义属性  `data-category1Id`、`data-category2Id`、`data-category3Id`来获取三个等级 a 标签的商品 id，用于路由跳转。 我们可以通过在函数中传入 event 参数，获取当前的点击事件，通过 `event.target` 属性获取当前点击节点，再通过 `dataset` 属性获取节点的属性信息。

```html
 <div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex">
          <div class="item"  v-for="(c1,index) in categoryList" v-show="index!==16" :key="c1.categoryId" :class="{cur:currentIndex===index}">
            <h3 @mouseenter="changeIndex(index)"  >
              <a :data-categoryName="c1.categoryName" :data-category1Id="c1.categoryId" >{{c1.categoryName}}</a>
            </h3>
            <div class="item-list clearfix" :style="{display:currentIndex===index?'block':'none'}">
              <div class="subitem" v-for="(c2,index) in c1.categoryChild" :key="c2.categoryId">
                <dl class="fore">
                  <dt>
                    <a :data-categoryName="c2.categoryName" :data-category2Id="c2.categoryId">{{c2.categoryName}}</a>
                  </dt>
                  <dd>
                    <em v-for="(c3,index) in c2.categoryChild"  :key="c3.categoryId">
                      <a :data-categoryName="c2.categoryName" :data-category3Id="c3.categoryId">{{c3.categoryName}}</a>
                    </em>
</dd></dl></div></div></div></div>
```
注意：event 是系统属性，所以我们只需要在函数定义的时候作为参数传入，在函数使用的时候不需要传入该参数。
```js
//函数使用
<div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex">
//函数定义
goSearch(event){
      console.log(event.target)
    }
```
对应的goSearrch函数
```js
goSearch(event){
      let element = event.target
      //html中会把大写转为小写
      //获取目前鼠标点击标签的categoryname,category1id,category2id,category3id，
      // 通过四个属性是否存在来判断是否为a标签，以及属于哪一个等级的a标签
      let {categoryname,category1id,category2id,category3id} = element.dataset


      //categoryname存在，表示为a标签
      if(categoryname){
        //category1id一级a标签
        //整理路由跳转的参数
        let location = {name:'Search'}//跳转路由name
        let query = {categoryName:categoryname}//路由参数

        if(category1id){
          query.category1Id = category1id
        }else if(category2id){
        //category2id二级a标签
          query.category2Id = category2id
        }else if(category3id){
        //category3id三级a标签
          query.category3Id = category3id
        }
        //整理完参数
        location.query = query
        //路由跳转
        this.$router.push(location)

      }
    },
```
# 16. Vue 路由销毁问题
> Vue 在路由切换的时候会销毁旧路由。 我们在三级列表全局组件TypeNav中的mounted进行了请求一次商品分类列表数据。 由于Vue在路由切换的时候会销毁旧路由，当我们再次使用三级列表全局组件时还会发一次请求。 如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求。 在这里插入图片描述 由于信息都是一样的，出于性能的考虑我们希望该数据只请求一次，所以我们把这次请求放在App.vue的mounted中。（根组件App.vue的mounted只会执行一次） 注意：虽然main.js也是只执行一次，但是不可以放在main.js中。因为只有组件的身上才会有$store属性。

# 17. mock 插件使用
mockjs 生成随机数据，当前端使用 mock 模拟的数据接口时，mockjs进行数据返回，并拦截 ajax 请求不发送给后台。     
使用步骤：  
- 1.在src下创建mock文件夹
- 2.准备JSON数据（mock文件夹中创建相应的JSON文件）
- 3.需要将相关的图片拷贝到 public/images目录下
- 4.创建mock.js，通过mockjs插件实现模拟数据
- 5.mockServe.js文件在入口文件中引入（至少需要执行一次，才能模拟数据）
  
封装一个 mock 请求的 axios
```js
const mockRequests = axios.create({
    baseURL:"/mock",
    timeout:5000, //请求超时的时间5s
})

//请求拦截器
mockRequests.interceptors.request.use((config)=>{
    //config:配置对象，对象里面有一个属性很重要，header请求头
    nprogress.start();//进度条开始
    return config;
})

//响应拦截器
//参数1成功的回调，参数2失败的回调
mockRequests.interceptors.response.use((res)=>{
    nprogress.done();//进度条结束
   return res.data;//返回服务器返回的数据

},(error)=>{
    return Promise.reject(new Error('fail')) //终止promise链
})

export default mockRequests;

//采用mock发送请求
import mockRequests from "./request";
//获取Home首页轮播图banner的结构
export const getBannerList = () => mockRequests.get('/banner');
```

# 18. vuex 数据存储与使用
我们会把公共的数据放在 store 中，然后使用时再去 store 中取。 以我们的首页轮播图数据为例。 

1、在轮播图组件 ListContainer.vue 组件加载完毕后发起轮播图数据请求。

 ```js
 mounted() {
    this.$store.dispatch("getBannerList")
  },
```
2、请求实际是在 store 中的 actions 中完成的

```js
actions:{
        //获取首页轮播图数据
        async getBannerList({commit}){
            let result = await reqGetBannerList()
            if(result.code ===  200){
                commit("BANNERLIST",result.data)
            }
        }
    }
```
3、获取到数据后存入 store 仓库，在 mutations 完成

```js
// 唯一修改 state 的部分
    mutations:{
        BANNERLIST(state,bannerList){
            state.bannerList = bannerList
        }
    },
```
4、轮播图组件 ListContainer.vue 组件在 store 中获取轮播图数据。由于在这个数据是通过异步请求获得的，所以我们要通过计算属性computed 获取轮播图数据。

ListContainer.vue代码

```js
import {mapState} from "vuex";
export default {
  name: "index",
  //主键挂载完毕，请求轮播图图片
  mounted() {
    this.$store.dispatch("getBannerList")
  },
  computed:{
    ...mapState({
      bannerList: (state => state.home.bannerList)
    })
  }
}
```
总结：只要是公共数据都会放在 store 中，之后的实现步骤就是上面的固定步骤。

# 19. swiper 插件实现轮播图

官网中给出了代码实例：
 
（1）安装 swiper   
（2）在需要**使用轮播图的组件内**导入 swpier 和它的 css 样式   
（3）在组件中创建 swiper 需要的 dom 标签（ html代码，参考官网代码 ）    
（4）创建 swiper 实例  

注意：在创建 swiper对象时，我们会传递一个参数用于获取展示轮播图的 DOM元素，官网直接通过 class（而且这个 class 不能修改，是 swiper 的 css文件自带的）获取。  
但是这样有*缺点*：当页面中有多个轮播图时，因为它们使用了相同的 class修饰的 DOM，就会出现所有的 swiper 使用同样的数据，这肯定不是我们希望看到的。   
解决方法：在轮播图**最外层 DOM 中添加 ref 属性**

`<div class="swiper-container" id="mySwiper" ref="cur"> 通过ref属性值获取DOM let mySwiper = new Swiper(this.$refs.cur,{...})`

```js
 <!--banner轮播-->
        <div class="swiper-container" id="mySwiper" ref="cur">

          <div class="swiper-wrapper">
            <div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id">
              <img :src="carouse.imgUrl" />
            </div>
          </div>

          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev" ></div>
          <div class="swiper-button-next"></div>
        </div>
<script>
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'
</script>
```

接下来要考虑的是什么时候去加载这个 swiper，我们第一时间想到的是在mounted 中创建这个实例。 但是会出现**无法加载轮播图片的问题**。  

### 原因：
> 我们在 mounted 中先去异步请求了轮播图数据，然后又创建的 swiper 实例。由于请求数据是异步的，所以浏览器不会等待该请求执行完再去创建swiper，而是先创建了 swiper实例，但是此时我们的轮播图数据还没有获得，就导致了轮播图展示失败。

```js
mounted() {
	//请求数据
    this.$store.dispatch("getBannerList")
    //创建swiper实例
    let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
      })
  },
```
解决方法一：等我们的数据请求完毕后再创建 swiper 实例。只需要加一个1000ms时间延迟再创建 swiper实例。将上面代码改为：  
```js
mounted() {
    this.$store.dispatch("getBannerList")
    setTimeout(()=>{
      let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
      })
    },1000)
  },
```
方法一肯定不是最好的，但是我们开发的第一要义就是实现功能，之后再完善。  

解决方法二：我们可以使用 watch 监听 bannerList 轮播图列表属性，因为 bannerList 初始值为空，当它有数据时，我们就可以创建 swiper 对象
```js
watch:{
    bannerList(newValue,oldValue){
        let mySwiper = new Swiper(this.$refs.cur,{
          pagination:{
            el: '.swiper-pagination',
            clickable: true,
          },
          // 如果需要前进后退按钮
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
          // 如果需要滚动条
          scrollbar: {
            el: '.swiper-scrollbar',
          },
        })
    }
  }
```
即使这样也还是无法实现轮播图，原因是，我们轮播图的 html 中有 v-for 的循环，我们是通过 v-for 遍历 bannerList 中的图片数据，然后展示。我们的 watch只能保证在 bannerList 变化时创建 swiper 对象，但是并不能保证此时 v-for 已经执行完了。假如 watch 先监听到 bannerList 数据变化，执行回调函数创建了swiper 对象，之后 v-for 才执行，这样也是无法渲染轮播图图片（因为 swiper 对象生效的前提是 html, 即 dom 结构已经渲染好了）。

**完美解决方案**：使用 watch + this.$nextTick()   
官方介绍：`this. $nextTick` 它会将回调延迟到下次 DOM更新 循环结束 之后执行（循环就是这里的 v-for）。 个人理解：无非是等我们页面中的结构都有了再去执行回调函数

完整代码
```js
<template>
  <!--列表-->
  <div class="list-container">
    <div class="sortList clearfix">
      <div class="center">
        <!--banner轮播-->
        <div class="swiper-container" id="mySwiper">

          <div class="swiper-wrapper">
            <div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id">
              <img :src="carouse.imgUrl" />
            </div>
          </div>

          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev" ></div>
          <div class="swiper-button-next"></div>
        </div>
      </div>
      </div>
    </div>
  </div>
</template>
<script>
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'

import {mapState} from "vuex";

export default {
  name: "index",
  //主键挂载完毕，ajax请求轮播图图片
  mounted() {
    this.$store.dispatch("getBannerList")
  },
  computed:{
    ...mapState({
    //从仓库中获取轮播图数据
      bannerList: (state) => {return state.home.bannerList}
    })
  },
  watch:{
    bannerList(newValue,oldValue){
        //this.$nextTick()使用
        this.$nextTick(()=>{
          let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
            pagination:{
              el: '.swiper-pagination',
              clickable: true,
            },
            // 如果需要前进后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev',
            },
            // 如果需要滚动条
            scrollbar: {
              el: '.swiper-scrollbar',
            },
          })
        })
    }
  }
}
</script>
```
注意：之前我们在学习watch时，一般都是监听定义在data中的属性，但是我们这里是监听的是computed中的属性，这样也是完全可以的，并且如果你的业务数据也是从store中通过computed动态获取的，也需要watch监听数据变化执行相应回调函数，完全可以模仿上面的写法。

# 20. props父子组件通信
原理：父组件设置一个属性绑定要传递的数据, 子组件 props 接受该属性值, 本项目的 父组件:home文件下的 index
```vue
<template>
<div>
// ...省略
<!--  父组件通过自定义属性list给子组件传递数据-->
  <Floor v-for="floor in floorList"  :key="floor.id" :list="floor"/>
<!--  商标-->
 
</div>
</template>
```

子组件：Floor下的 index.vue
```vue
<template>
  <!--楼层-->
  <div class="floor">
    //...省略
  </div>
</template>

<script>
export default {
  name: "floor",
//子组件通过props属性接受父组件传递的数据
  props:['list']
}
</script>
```
上面两代码一看，发现父子组件竟然都是Floor组件，这使得我们对父子组件的概念难以理解。 个人理解1： 我们Floor文件夹下的index.vue创建了Floor组件，我们把它认为子组件。 我们在home文件夹下引用了该组件并使用了它，具体表现为
`<Floor v-for="floor in floorList" :key="floor.id" :list="floor"/>`，此处使用的 Floor标签，我们将其称为父组件。 个人理解2： Floor是子组件，我们在home组件中调用了Floor，我们把home组件认为父组件，我们在home组件中实现了由home组件向Floor组件传递信息的操作，即父组件向子组件传递信息。

我们的目的是将 floorList 中的数据分发给 Floor 组件。

# 21. 将轮播图模块提取为公共组件
需要注意的是我们要把定义swiper对象放在mounted中执行，并且还要设置`immediate：true`属性，这样可以实现无论数据有没有变化，上来立即监听一次。 上一小节刚刚讲了props实现父组件向子组件传递消息，这里同样也会将轮播图列表传递给子组件，原理相同。 公共组件Carousel代码：
```vue
<template>
  <div class="swiper-container" ref="cur">
    <div class="swiper-wrapper">
      <div class="swiper-slide" v-for="carousel in list" :key="carousel.id">
        <img :src="carousel.imageUrl" />
      </div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>

    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
  </div>
</template>

<script>
import Swiper from "swiper";
export default {
  // eslint-disable-next-line vue/multi-word-component-names
  name: "Carsousel",
  props: ["list"],

  watch: {
    list: {
      //立即监听：不管数据有无变化，上来立即监听一次
      // 为什么watch监听不到list: 因为这个数据从来没有发生变化（数据是父亲给的。父亲给的时候就是一个对象，对象里面该有的数据都是有的）
      immediate: true,
      handler() { 
        // 只能监听到数据已经有了，但是v-for 动态渲染结构还是没有办法确定，因此还是需要nextTick
        this.$nextTick(() => {
          // eslint-disable-next-line no-unused-vars
          let mySwiper = new Swiper(this.$refs.cur, {
            loop: true,
            pagination: {
              el: ".swiper-pagination",
              clickable: true,
            },
            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },
};
</script>
```

注册全局组件并引用

```js
import Carsousel from '@/components/Carsousel'
// 第一个参数：全局组件的名字，第二个参数：哪一个组件
Vue.component(Carsousel.name, Carsousel)
```
Floor 组件引用 Carousel组件`<Carousel :lList="list.carouselList"/>` 我们还记得在首页上方我们的ListContainer组件也使用了轮播图，同样我们替换为我们的公共组件。 ListContainer组件引用 Carousel组件 `<Carouse :list="bannerList"/>`   

# search组件开发
1. 先静态页面 + 静态组件拆分出来
2. 发请求 (API)
3. vuex (三连环)
4. 组件获取仓库数据，动态展示数据

# 22. getters使用

getters 是 vuex store 中的计算属性。 如果不使用getters属性，我们在组件获取 state 中的数据表达式为：`this.$store.state.子模块.属性`， 如果有多个组件需要用到此属性，我们要么复制这个表达式，或者抽取到一个共享函数然后在多处导入它——-无论哪种方式都不是很理想。   
Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 个人理解：getters 将获取 store中的数据封装为函数，代码维护变得更简单（和我们将请求封装为api一样）。而且 getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。   
注意：仓库中的 getters 是全局属性，是不分模块的。即 store 中所有模块的 getter 内的函数都可以通过`$store.getters.函数名` 获取 store 内容, 我们在 Search 模块中获取商品列表数据就是通过 getters 实现，需要注意的是当网络出现故障时应该将返回值设置为空，如果不设置返回值就变成了undefined。

store中search模块代码
```js
import {reqGetSearchInfo} from '@/api';
const state = {
    searchList:{},
}
const mutations = {
    SEARCHLIST(state,searchList){
        state.searchList = searchList
    }
}
const actions = {
    //第二个参数data默认是一个空对象
    async getSearchListr({commit},data={}){
        let result = await reqGetSearchInfo(data)

        if(result.code === 200){
            commit("SEARCHLIST",result.data)
        }
    }
}
const getters = {
    goodsList(state){
        //网络出现故障时应该将返回值设置为空
        return state.searchList.goodsList||[]
    }
}
export default {
    state,
    mutations,
    actions,
    getters,
}
```
在Search组件中使用getters获取仓库数据
```vue
// 只展示了使用getters的代码
<script>
  // 引入mapGetters
  import {mapGetters} from 'vuex'
  export default {
    name: 'Search',
    computed:{
      //使用 mapGetters，参数是一个数组，数组的元素对应 getters 中的函数名
      ...mapGetters(['goodsList'])
    }
  }
</script>
```
 后续数据的动态渲染就和之前模块相同，没有什么难度。

# 23. Object.asign实现对象拷贝

```js
// Object.assign()  方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
Object.assign(target, ...sources)    // 【target：目标对象】，【souce：源对象（可多个）】
// 举个栗子：
const object1 = {
  a: 1,
  b: 2,
  c: 3
};

const object2 = Object.assign({c: 4, d: 5}, object1);

console.log(object2.c, object2.d);
console.log(object1)  // { a: 1, b: 2, c: 3 }
console.log(object2)  // { c: 3, d: 5, a: 1, b: 2 }
```
## 注意：  
1. 如果目标对象中的属性具有相同的键，则属性将**被源对象中的属性覆盖**。后面的源对象的属性将类似地覆盖前面的源对象的属性
2. Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标
对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如
果合并源包含 getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到
原型，应使用 `Object.getOwnPropertyDescriptor()`和`Object.defineProperty()`。




# 24. 对象深拷贝

```js
// 针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。
let obj1 = { a: 0 , b: { c: 0}}; 
let obj2 = Object.assign({}, obj1); 
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 

obj1.a = 1; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} 
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 

obj2.a = 2; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} 
console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}
 
obj2.b.c = 3; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}} 
console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}} 
// 最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响

// Deep Clone （深拷贝）
obj1 = { a: 0 , b: { c: 0}}; 
let obj3 = JSON.parse(JSON.stringify(obj1)); 
obj1.a = 4; 
obj1.b.c = 4; 
console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}
```

# 25. 利用路由信息变化实现动态搜索

最初想法：在每个三级列表和收缩按钮加一个点击触发事件，只要点击了就执行搜索函数。 这是一个很蠢的想法，如果这样就会生成很多回调函数，很耗性能。 最佳方法：我们每次进行新的搜索时，我们的query和params参数中的部分内容肯定会改变，而且这两个参数是路由的属性。我们可以通过监听路由信息的变化来动态发起搜索请求。

如下图所示，$route是组件的属性，所以watch是可以监听的（watch可以监听组件data中所有的属性） 注意：组件中data的属性包括：自己定义的、系统自带的（如 $route）、父组件向子组件传递的等等。 在这里插入图片描述 search组件watch部分代码。

```js
watch:{
      $route(newValue,oldValue){
        Object.assign(this.searchParams,this.$route.query,this.$route.params)
        this.searchInfo()
        // 如果下一次搜索时只有 params参数，拷贝后会发现 searchParams 会保留上一次的 query 参数
        // 所以每次请求结束后将相应参数制空
        this.searchParams.category1Id = undefined;
        this.searchParams.category2Id = undefined;
        this.searchParams.category3Id = undefined;
        this.$route.params.keyword = undefined;
      }
    },
```

# 组件通信方式

>组件间通信的集中方式：https://www.cnblogs.com/yszblog/p/10135969.html

第一种父子组件通信：

- \$on、$emit 自定义事件实现子组件给父组件传递信息。 props实现父组件给子组件传递数据。

第二种全局事件总线：  $bus（适用于所有的场景） 

第三种： Vuex 

第四种： 插槽（适用于父子组件通信

# 26. 面包屑相关操作
本次项目的面包屑操作主要就是两个删除逻辑。   
分为： 当分类属性（query）删除时删除面包屑同时修改路由信息。   
当搜索关键字（params）删除时删除面包屑、修改路由信息、同时删除输入框内的关键字。  
1、query 删除时 因为此部分在面包屑中是通过 categoryName 展示的，所以删除时应将该属性值置空或 undefined。 可以通过路由再次跳转修改路由信息和 url链接。
```js
//删除分类
      removeCategoryName(){
        this.searchParams.categoryName = undefined
        this.$router.push({name:'Search',params:this.$route.params})
      },
```
2、params删除时和 query删除的唯一不同点是此部分会多一步操作：删除输入框内的关键字（因为 params参数是从输入框内获取的）
输入框是在 Header组件中的， header和search组件是兄弟组件，要实现该操作就要通过兄弟组件之间进行通信完成。这里通过 $bus实现header 和 search组件的通信。  
\$bus使用:  
（1）在 main.js 中注册

```js
new Vue({
  //全局事件总线 $bus配置
  beforeCreate() {
    //此处的 this就是这个 new Vue()对象
    //网络有很多 bus通信总结，原理相同，换汤不换药
    Vue.prototype.$bus = this
  },
  render: h => h(App),
  // router2、注册路由，此时组件中都会拥有$router $route属性
  router,
  // 注册store,此时组件中都会拥有$store
  store
}).$mount('#app')
```
（2）search 组件使用 \$bus通信，第一个参数可以理解为为通信的暗号，还可以有第二个参数（用于传递数据），我们这里只是用于通知header组件进行相应操作，所以没有设置第二个参数。
```js
      //删除搜索关键字
      removeBreadParams(){
        this.searchParams.keyword = undefined
        //通知兄弟组件 header删除输入框的 keyword关键字
        this.$bus.$emit("clear")
        this.$router.push({name:'Search',query:this.$route.query})
      },
```
（3）header 组件接受 $bus通信 注意：组件挂载时就监听 clear事件
```js
mounted() {
  //  组件挂载时就监听clear事件，clear事件在search模块中定义
  //  当删除关键字面包屑时，触发该事件，同时 header的输入框绑定的 keyword要删除
    this.$bus.$on("clear",()=>{
      this.keyword = ''
    })
  }
```
# 27. SearchSelector子组件传参及面包屑操作
在26小节中描述了通过 query、params 参数生成面包屑，以及面包屑的删除操作对应地址栏 url的修改。   
SearchSelector 组件有两个属性也会生成面包屑，分别为**品牌名、手机属性**。此处生成面包屑时会涉及到**子组件向父组件传递信息**操作（在'组件通信方式'小节有相关知识点），之后的操作和前面26小节讲的面包屑操作原理相同。唯一的区别是，这里删除面包屑时不需要修改地址栏 url，因为 url是由路由地址确定的，并且只有query、params两个参数变化会影响路由地址变化。   
在具体的操作内还会涉及一些小的知识点，例如：字符串拼接 `${}`，使用方法如下:
```
var a = 1;
console.log(`a的值是：${a}`); //a的值是：1
```
至此面包屑部分内容结束。 
总结：面包屑由四个属性影响：parads、query、品牌、手机属性；   
面包屑 生成逻辑： 判断 searchParams相关属性是否存在，存在即显示。   
面包屑 删除逻辑：   
Search.vue js代码()  
```js

    //在组件挂在之前动态编辑searchParams的值，因为组件挂在之后会使用到searchParams
    beforeMount() {
      //Object.assign方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
      //Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象
      Object.assign(this.searchParams,this.$route.query,this.$route.params)
    },
    methods:{
      //搜索
      searchInfo(){
        this.$store.dispatch("getSearchListr",this.searchParams)
      },
      //删除分类(query)面包屑
      removeBread(){
        this.searchParams.categoryName = undefined
        this.$router.push({name:'Search',params:this.$route.params})
      },
      //删除搜索关键字(params)面包屑
      removeBreadParams(){
        this.searchParams.keyword = undefined
        //通知兄弟组件header删除输入框的keyword关键字
        this.$bus.$emit("clear")
        this.$router.push({name:'Search',query:this.$route.query})
      },
      //获取子组件传递的品牌信息（自定义事件）
      tradeMarkInfo(tradeMark){
        //接口文档中trademark的信息是"ID:品牌名称"形式
        this.searchParams.trademark = `${tradeMark.tmId}:${tradeMark.tmName}`
        this.searchInfo()
      },
      //删除品牌面包屑
      removeTradeMark(){
        this.searchParams.trademark = undefined
        this.searchInfo()
      },
      //获取子组件传递的属性信息（自定义事件）
      attrInfo(attr,attrValue){
        //searchParams.props元素为字符串形式，api文档有介绍
        let props = `${attr.attrId}:${attrValue}:${attr.attrName}`
        //数组去重
        if(this.searchParams.props.indexOf(props)===-1){
          this.searchParams.props.push(props)
          this.searchInfo()
        }
      },
      //删除属性面包屑
      removeAttr(index){
        this.searchParams.props.splice(index,1)
      }
    },
    mounted() {
      this.searchInfo()
    },
    computed:{
      ...mapGetters(['goodsList'])
    },
    //watch可以监听组件上的属性
    watch:{
      $route:{
        handler(newValue,oldValue){
          console.log(this.$route)
          Object.assign(this.searchParams,this.$route.query,this.$route.params)
          this.searchInfo()
          //如果下一次搜索时只有params参数，拷贝后会发现searchParams会保留上一次的query参数
          //所以每次请求结束后将相应参数制空
          this.searchParams.category1Id = '';
          this.searchParams.category2Id = '';
          this.searchParams.category3Id = '';
        },
      }
    },
```

# 28. 商品排序
排序的逻辑比较简单，只是改变一下请求参数中的 order字段，后端会根据order 值返回不同的数据来实现升降序。   
order 属性值为字符串，例如：'1：asc'、'2：desc'。1 代表综合，2 代表价格，asc 代表升序，desc 代表降序。

我们的升降序是通过箭头图标来辨别的，图标是 iconfont网站的图标，通过引入在线css的方式引入图标；在public文件index中引入该css   
`<link rel="stylesheet" href="https://at.alicdn.com/t/font_2994457_qqwrvmss9l9.css">`

在 search 模块使用该图标
```html
<div class="sui-navbar">
            <div class="navbar-inner filter">
              <ul class="sui-nav">
<!-- 这里isOne、isTwo、isAsc、isDesc是计算属性，如果不使用计算属性要在页面中写很长的代码-->
                <li :class="{active:isOne}" @click="changeOrder('1')">
<!--                  阿里图标前置类iconfont-->
                  <a  >综合<span v-show="isOne" class="iconfont" :class="{'icon-up':isAsc,'icon-down':isDesc}"></span></a>
                </li>
                <li :class={active:isTwo} @click="changeOrder('2')">
                  <a >价格<span v-show="isTwo" class="iconfont" :class="{'icon-up':isAsc,'icon-down':isDesc}"></span></a>
                </li>
              </ul>
            </div>
          </div>
```

isOne、isTwo、isAsc、isDesc 计算属性代码

```js
computed:{
      ...mapGetters(['goodsList']),
      isOne(){
        return this.searchParams.order.indexOf('1')!==-1
      },
      isTwo(){
        return this.searchParams.order.indexOf('2')!==-1
      },
      isDesc(){
        return this.searchParams.order.indexOf('desc')!==-1
      },
      isAsc(){
        return this.searchParams.order.indexOf('asc')!==-1
      },
    },
```

点击‘综合’或‘价格’的触发函数changeOrder

```js
      //flag用于区分综合、价格，1：综合，2：价格
      changeOrder(flag){
        let newSearchOrder = this.searchParams.order
        //将order拆为两个字段orderFlag(1:2)、order(asc:desc)
        let orderFlag = this.searchParams.order.split(':')[0]
        let order = this.searchParams.order.split(':')[1]
        //由综合到价格、由价格到综合
        if(orderFlag!==flag){
          //点击的不是同一个按钮
          newSearchOrder = `${flag}:desc`
          this.searchInfo()
        }else{
          //多次点击的是不是同一个按钮
          newSearchOrder = `${flag}:${order==='desc'?'asc':'desc'}`
          }
        //需要给order重新赋值
        this.searchParams.order = newSearchOrder;
        //再次发请求
        this.searchInfo();
      }
```

# 29. 手写分页器 | 封装通用组件  

分页器需要哪些数据？  

1. 当前是第几页: pageNo
2. 每一页需要展示多少数据: pageSize
3. 分页器一共有多少条数据: total
4. 分页器显示的连续页码个数:5 | 7 【奇数】 continues（连续展示的页码）

对于分页器，很重要的点是**计算出连续显示页面号起始数字和结束数字**。 当前页在连续页的正中间

- 计算总共多少页：Math.ceil(total/pagesize) // 向上取整
- 计算出连续的页码的**起始数字与结束数字**

```js
 computed: {
    //总共多少页
    totalPage() {
      return Math.ceil(this.total / this.pageSize);
    },
    //计算出连续的页码的起始数字与结束数字[连续页码的数字:至少是5]
    startNumAndEndNum() {
      const { continues, pageNo, totalPage } = this;
      //先定义两个变量存储起始数字与结束数字
      let start = 0,  end = 0;
      //不正常现象【总页数没有连续页码多】
      if (continues > totalPage) {
        start = 1;
        end = totalPage;
      } else {
        //正常现象【连续页码5，但是你的总页数一定是大于 5的】
        start = pageNo - parseInt(continues / 2);
        end = pageNo + parseInt(continues / 2);
        //把出现不正常的现象【start数字出现0|负数】纠正
        if (start < 1) {
          start = 1;
          end = continues;
        }
        //把出现不正常的现象[end数字大于总页码]纠正
        if (end > totalPage) {
          end = totalPage;
          start = totalPage - continues + 1;
        }
      }
      return { start, end };
    },
  }

```

核心逻辑是获取连续页码的起始页码和末尾页码，通过计算属性获得。（计算属性如果想返回多个数值，可以通过对象形式返回）

```js
// 连续页码的起始页码、末尾页码
  //连续页码的起始页码、末尾页码
    startNumAndEnd(){
      let start = 0 , end = 0;
      //规定连续页码数字5（totalPage至少5页）
      //不正常现象
      if(this.continues > this.totalPage){
        start = 1
        end = this.totalPage
      }else{
        //正常现象      Math.floor:想下取整
        start = this.pageNo - Math.floor(this.continues/2)
        end = this.pageNo + Math.floor(this.continues/2)
        //start出现不正常现象纠正
        if(start < 1){
          start = 1
          end = this.continues
        }
        //end出现不正常现象纠正
        if(end > this.totalPage){
          end = this.totalPage
          start = this.totalPage - this.continues + 1
        }
      }
      return {start,end}
    }
```
当点击页码会将pageNo传递给父组件，然后父组件发起请求，最后渲染。这里还是应用通过自定义事件实现子组件向父组件传递信息

# 30. 商品详情
当点击商品的图片的时候，跳转到详情页面，在路由跳转的时候需要带上产品的ID给详情页面  
商品详情唯一难点就是点击轮播图图片时，改变放大镜组件展示的图片。   
老师的方法很巧妙：在轮播图组件中设置一个 currendIndex，用来记录所点击图片的下标，并用 currendIndex实现点击图片高亮设置。当符合图片的下标满足 `currentIndex===index`时，该图片就会被标记为选中。
```html
  <div class="swiper-container" ref="cur">
    <div class="swiper-wrapper">
      <div class="swiper-slide" v-for="(skuImage,index) in skuImageList" :key="skuImage.id">
        <img :src="skuImage.imgUrl" :class="{active:currentIndex===index}" @click="changeImg(index)">
      </div>
    </div>
    <div class="swiper-button-next"></div>
    <div class="swiper-button-prev"></div>
  </div>
```
轮播图组件和放大镜组件是兄弟组件，所以要通过全局总线通信。 在轮播图组件中，点击图片触发全局事件changeImg，参数为图片所在数组的下标。
```js
 changeImg(index){
        //将点击的图片标识位高亮
        this.currentIndex = index
        //通知兄弟组件修改大图图片
        this.$bus.$emit("changeImg",index)
      }
```
对应的放大镜组件，首先在mounted监听该全局事件
```js
mounted() {
      this.$bus.$on("changeImg",(index)=>{
        //修改当前响应式图片
        this.currentIndex = index;
      })
    },
```

放大镜组件中也会有一个currentIndex，他用表示大图中显示的图片的下标（因为放大镜组件只能显示一张图片），全局事件传递的index赋值给currentIndex ，通过computed计算属性改变放大镜组件展示的图片下标。
```js
computed:{
      imgObj(){
          return this.skuImageList[this.currentIndex] || {}
      }
    },
```

放大镜组件展示图片的html代码
```html
<img :src="imgObj.imgUrl " />
```

JS实现放大镜功能
> https://blog.csdn.net/weixin_40758850/article/details/89445629

# 31. 失焦事件
blur与change事件在绝大部分情况下表现都非常相似，输入结束后，离开输入框，会先后触发change与blur，唯有两点例外。 （1） 没有进行任何输入时，不会触发change。 在这种情况下，输入框并不会触发change事件，但一定会触发blur事件。在判断表单修改状态时，这种差异会非常有用，通过change事件能轻易地找到哪些字段发生了变更以及其值的变更轨迹。

（2）输入后值并没有发生变更。 这种情况是指，在没有失焦的情况下，在输入框内进行返回的删除与输入操作，但最终的值与原值一样，这种情况下，keydown、input、keyup、blur都会触发，但change依旧不会触发。

# 32. 加入购物车成功路由
点击加入购物车时，会向后端发送API请求，但是该请求的返回值中data为null，所以我们只需要根据状态码code判断是否跳转到‘加入购物车成功页面’。 detail组件‘加入购物车’请求函数：
```js
async addShopCar() {
        try{
          await  this.$store.dispatch("addOrUpdateShopCart", {
            skuId: this.$route.params.skuId,
            skuNum: this.skuNum
          });
          // 一些简单的数据，比如 skuNum通过 query传过去
          // 复杂的数据通过 session存储，
          // sessionStorage、localStorage只能存储字符串        sessionStorage.setItem("SKUINFO",JSON.stringify(this.skuInfo))
          this.$router.push({name:'AddCartSuccess',query:{'skuNum':this.skuNum}})
        }catch (error){
          alert(error.message)
        }
      }
```
detail store对应代码
```js
//将产品添加到购物车中
    async addOrUpdateShopCart({commit},{skuId,skuNum}){
        let result = await reqAddOrUpdateShopCart(skuId,skuNum)
        if(result.code === 200){
            return 'ok'
        }else{
            return Promise.reject(new Error('faile'))
        }
    }
```
其实这里当不满足 `result.code === 200` 条件时，也可以返回字符串‘faile’，自己在addShopCar中判断一下返回值，如果为‘ok’则跳转，如果为‘faile’(或者不为‘ok’)直接提示错误。当然这里出错时返回一个Promise.reject更加符合程序的逻辑。

> 跳转‘加入购物车成功页面’的同时要携带商品的信息。本项目只是传递的商品的一些标签属性，并没有传递商品的型号类别的信息，比如颜色、内存等信息。

当我们想要实现两个**毫无关系的组件传递数据**时，首相想到的就是路由的 query传递参数，但是query适合传递单个数值的简单参数，所以如果想要传递对象之类的复杂信息，就可以通过Web Storage实现。

**sessionStorage、localStorage概念**： 
sessionStorage：为每一个给定的源维持一个独立的存储区域，该区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。       
localStorage：同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。     
注意：无论是session还是local存储的值都是字符串形式。如果我们想要存储对象，需要在存储前JSON.stringify()将对象转为字符串，在取数据后通过 JSON.parse() 将字符串转为对象。

# 33. 购物车组件开发

根据 api 接口文档封装请求函数
```js
export const reqGetCartList = () => {
return requests({
	url:'/cart/cartList',
	method:'GET'
})}
```

但是如果想要获取详细信息，还需要一个用户的 uuidToken，用来验证用户身份。但是该请求函数没有参数，所以我们只能把 uuidToken 加在请求头中。

创建utils工具包文件夹，创建生成 uuid的 js文件，对外暴露为函数（记得导入 uuid => npm install uuid）。 **生成临时游客的 uuid（随机字符串）,每个用户的 uuid不能发生变化，还要持久存储**
```js
import {v4 as uuidv4} from 'uuid'
//生成临时游客的uuid（随机字符串）,每个用户的uuid不能发生变化，还要持久存储
export const getUUID = () => {
    //1、判断本地存储是否有uuid
    let uuid_token = localStorage.getItem('UUIDTOKEN')
    //2、本地存储没有uuid
    if(!uuid_token){
        //2.1生成uuid
        uuid_token = uuidv4()
        //2.2存储本地
        localStorage.setItem("UUIDTOKEN",uuid_token)
    }
    //当用户有uuid时就不会再生成
    return uuid_token
}
```
用户的 uuid_token 定义在 store中的 detail模块

```js
const state =  {
    goodInfo:{},
    //游客身份
    uuid_token: getUUID()
}
```
在request.js中设置请求头
```js
import store from '@/store';
requests.interceptors.request.use(config => {
    //config内主要是对请求头Header配置

    //1、先判断uuid_token是否为空
    if(store.state.detail.uuid_token){
        //2、userTempId字段和后端统一
        config.headers['userTempId'] = store.state.detail.uuid_token
    }
    //比如添加token

    //开启进度条
    nprogress.start();
    return config;
})
```
注意 this.$store 只能在组件中使用，不能在 js文件中使用。如果要在 js中使用，需要引入`import store from '@/store';`

# 34. 购物车商品数量修改及个人疑问
1、购物车商品信息展示比较简单，就不多做赘述。    
2、every 函数使用
> every 遍历某个数组，判断数组中的元素是否满足表达式，全部满足返回 true，否则返回 false，遇到一个false则返回false

例如判断底部勾选框是否全部勾选代码部分
```js
//判断底部勾选框是否全部勾选
      isAllCheck() {
        //every遍历某个数组，判断数组中的元素是否满足表达式，全部为满足返回true，否则返回false
        return this.cartInfoList.every(item => item.isChecked === 1)
      }
```
3、修改商品数量前端代码部分： 注意：通过 @click、@change 触发 handler函数改变商品数量。  
```html
 <li class="cart-list-con5">
     <a href="javascript:void(0)" class="mins" @click="handler('minus',-1,cartInfo)">-</a>
     <input autocomplete="off" type="text" :value="cartInfo.skuNum" @change="handler('change',$event.target.value,cartInfo)" minnum="1" class="itxt">
     <a href="javascript:void(0)" class="plus" @click="handler('add',1,cartInfo)">+</a>
 </li>
```
handler函数，修改商品数量时，加入节流操作。
> 添加到购物车和对已有物品进行数量改动使用的同一个api，可以查看api文档。 handler函数有三个参数，type区分操作，disNum用于表示数量变化（正负）,cart商品的信息
```js
 //加入节流操作
 handler: throttle(async  function(type,disNum,cart){
       //减按钮判断当前数量是否为1
    if(type === 'minus') {
       //当商品数量为1是，不可以再减少
       if(cart.skuNum === 1){
           return;
       }
    }
   //输入框修改,难点：要判断输入的内容是否合法
    if(type === 'change'){
       //输入内容不合法时
        if(isNaN(disNum * 1)  || disNum <= 0){
          disNum = 0;
        }else{
          disNum = parseInt(disNum) - cart.skuNum
        }
    }
   //加按钮disNum不需要改变
   try{
       await this.$store.dispatch('addOrUpdateShopCart',{skuId:cart.skuId,skuNum:disNum})
    //商品数量修改成功后再次获取服务器数据
       await this.$store.dispatch("getCartList")

   }catch (error){
       alert(error)
   }
},100),
```

# 35. 购物车状态修改和商品删除
这部分都比较简单，这里不多做赘述，唯一需要注意的是当store的action中的函数返回值data为null时，应该采用下面的写法（重点是if，else部分）

action部分：以删除购物车某个商品数据为例
```js
//修改购物车某一个产品的选中状态
    async reqUpdateCheckedById({commit},{skuId,isChecked}){
        let result = await reqUpdateCheckedById(skuId,isChecked)
        if(result.code === 200){
            return 'ok'
        }else{
            return Promise.reject(new Error('fail'))
        }
    }
```
method部分：（重点是try、catch）
```js
async reqUpdateCheckedById(cart,event){
        let isChecked = event.target.checked ? 1 :0
        try{
          await this.$store.dispatch("reqUpdateCheckedById",{skuId:cart.skuId,isChecked:isChecked})
          //修改成功，刷新数据
          this.$store.dispatch()
        }catch (error){
          this.$store.dispatch("getCartList")
        }
      }
```
# 36. 删除多个商品（actions扩展）

由于后台只提供了删除单个商品的接口，所以要删除多个商品时，只能多次调用actions中的函数。 我们可能最简单的方法是在method的方法中多次执行dispatch删除函数，当然这种做法也可行，但是为了深入了解actions，我们还是要将批量删除封装为actions函数。 actions扩展 官网的教程，一个标准的actions函数如下所示：
```
 deleteAllCheckedById(context) {
        console.log(context)

    }
```
我们可以看一下 context到底是什么。 context中是包含 dispatch、getters、state的，即我们可以在 actions函数中通过 dispatch调用其他的 actions函数，可以通过 getters获取仓库的数据。 这样我们的批量删除就简单了，对应的actions函数代码让如下:
```js
// 删除选中的所有商品
    deleteAllCheckedById({dispatch,getters}) {
        getters.getCartList.cartInfoList.forEach(item =>  {
            let result = [];
            // 将每一次返回值添加到数组中
            result.push(item.isChecked === 1?dispatch('deleteCartById',item.skuId):'')   
        })
	return Promise.all(result)
    },
```
上面代码使用到了Promise.all
> Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。

购物车组件method批量删除函数
```js
//删除选中的所有商品
      async deleteAllCheckedById(){
        try{
          await this.$store.dispatch('deleteAllCheckedById')
          //删除成功，刷新数据
          this.$store.dispatch("getCartList")
        }catch (error){
          alert(error)
        }
      },
```

修改商品的全部状态和批量删除的原理相同。 actions
```js
// 修改购物车全部产品的选中状态
    async updateAllChecked({dispatch,getters},flag){
        let result = []
        getters.getCartList.cartInfoList.forEach(item => {
            result.push(dispatch('reqUpdateCheckedById',{skuId:item.skuId,isChecked:flag
            }))
        })
        return Promise.all(result)
    }
```
method
```js
 //修改全部商品的状态
      async allChecked(event){
         let flag =  event.target.checked ? 1 : 0
         console.log(flag)
         try{
           await this.$store.dispatch('updateAllChecked',flag)
           //修改成功，刷新数据
           this.$store.dispatch("getCartList")
         }catch (error){
           alert(error)
         }
      }
```
bug纠正 computed中的cartInfoList没有写[ ]返回值。当后台返回的购物车数据为空时，cartInfoList 就会为undefined，会导致后面的total、isAllCheck等计算属性使用到cartInfoList时产生计算错误。

正确代码：
```
 cartInfoList(){
        return this.getCartList.cartInfoList || [];
      },
```
错误代码
```
 cartInfoList(){
        return this.getCartList.cartInfoList;
      },
```
# 37. 注册登录业务(ES6 const新用法)

### 1、 ES6 const新用法
```
const {comment,index,deleteComment} = this 
```
上面的这句话是一个简写，最终的含义相当于:

```
const  comment = this.comment
const  index = this.index
const   deleteComment = this.deleteComment
```
### 2、 用户注册模块 actions部分(验证码部分省略)
```js
//用户注册
    async userRegister({commit},data){
        let result = await reqPostRegister(data)
        if(result.code === 200){
            return 'ok'
        }else{
            return Promise.reject(new Error(result.message))
        }
    }
```
methods注册功能 注册成功跳转到登陆页面，并且携带用户账号（个人完善）
```js
      async userRegister(){
        const{phone,password,code} = this
        try{
          phone && password && code && await this.$store.dispatch('userRegister',{phone,password,code})
        
        /*  //注册成功跳转到登陆页面，并且携带用户账号
          await this.$router.push({path:'/login',query:{name:this.phone}}) */
          // 原始
          this.$router.push('/login')
        }catch (error){
          alert(error)
        }
      },
```
`this.$store.dispatch('userRegister',{phone,password,code})`因为K 、V相同，所以只传K 3、登录模块 前端部分内容
```html
			<form >
              <div class="input-text clearFix">
                <span></span>
                <input type="text" placeholder="邮箱/用户名/手机号" v-model="phone">
              </div>
              <div class="input-text clearFix">
                <span class="pwd"></span>
                <input type="password" placeholder="请输入密码" v-model="password">
              </div>
              <div class="setting clearFix">
                <label class="checkbox inline">
                  <input name="m1" type="checkbox" value="2" checked="">
                  自动登录
                </label>
                <span class="forget">忘记密码？</span>
              </div>
              <button class="btn" @click.prevent="goLogin">登&nbsp;&nbsp;录</button>
      </form>
```
由于登录按钮的**父节点是一个 form表单**，如果使用 @click触发登录事件，form表单会执行默认事件：action实现页面跳转。这里我们使用`@click.prevent`，它可以阻止自身默认事件的执行。  
actions登陆函数
```js
//登录
    async userLogin({commit},data){
        let result = await reqPostLogin(data)
        //服务器会返回token
        if(result.code === 200){
            //token存入vuex
            commit("SETUSERTOKEN",result.data.token)
            //持久化存储token
            localStorage.setItem('TOKEN',result.data.token)
            return 'ok'
        }else{
            return Promise.reject(new Error(result.message))
        }
    },
```

mutations设置用户token

```js
//设置用户token
    SETUSERTOKEN(state,token){
        state.token = token
    }
```
登陆组件methods登陆函数
```js
 async goLogin(){
        try{
          //会将this中的phone,password以对象的形式返回
          const {phone,password} = this
          phone && password && await this.$store.dispatch('userLogin',{phone,password})
          //路由跳转到home首页
          this.$router.push('/home')
        }catch (error){
          alert(error)
        }
      }
```
登陆成功后获取用户信息 actions函数
```js
async getUserInfo({commit}){
        let result = await reqGetUserInfo();
        //将用户信息存储到store中
        if(result.code === 200){
            //vuex存储用户信息
            commit('SETUSERINFO',result.data)
            return  'ok'
        }else{
            return Promise.reject(new Error(result.message))
        }
    },
```
mutations存储用户信息
```js
//存储用户信息
    SETUSERINFO(state,data){
        state.userInfo = data
    },
```

# 38. 导航守卫
思路：直接看流程图 为什么要判断name？



> 因为 store中的 token是通过 localStorage获取的，token有存放在本地。当页面刷新时，本地 token不会消失，所以 store中的 token也不会消失。但是，store中的其他数据（用户信息等）会清空，此时会出现用户信息不存在，但是有 token，这种情况是不可以访问其他页面的，必须先去获取用户信息。由于用户信息是一个对象，所以我们通过它的一个属性 name判断用户信息是否存在。 所以不仅要判断token,还要判断用户信息

router index.js全局前置守卫代码

```js
//设置全局导航前置守卫
router.beforeEach(async(to, from, next) =>  {
    let token = store.state.user.token
    let name = store.state.user.userInfo.name
    //1、有token代表登录，全部页面放行
    if(token){
        //1.1登陆了，不允许前往登录页
        if(to.path==='/login'){
            next('/home')
        } else{
            //1.2、因为store中的token是通过localStorage获取的，token有存放在本地
            // 当页面刷新时，token不会消失，但是store中的其他数据会清空，
            // 所以不仅要判断token,还要判断用户信息

            //1.2.1、判断仓库中是否有用户信息，有放行，没有派发actions获取信息
            if(name)
                next()
            else{
                //1.2.2、如果没有用户信息，则派发actions获取用户信息
                try{
                    await store.dispatch('getUserInfo')
                    next()
                }catch (error){
                    //1.2.3、获取用户信息失败，原因：token过期
                    //清除前后端token，跳转到登陆页面
                    await store.dispatch('logout')
                    next('/login')
                }
            }
        }
    }else{
        //2、未登录，首页或者登录页可以正常访问
        if(to.path === '/login' || to.path === '/home' || to.path==='/register')
            next()
        else{
            alert('请先登录')
            next('/login')
        }
    }
})
```





