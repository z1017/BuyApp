# 前端Vue核心
开发一个前端模块可以概括为以下几个步骤： 
- （1）写静态页面、拆分为静态组件； 
- （2）发请求（API）； 
- （3）vuex（actions、mutations、state 三连操作）； 
- （4）组件获取仓库数据，动态展示；

# 1、vue文件目录分析
```
.文件目录
├── node_modules：项目依赖文件夹
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放公用的静态资源
│   │   └── logo.png
│   │── component: 非路由组件（全局组件），其他组件放在views或者pages文件夹中
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件 （唯一的根组件
│   └── main.js: 程序入口文件，最先执行的文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
└── package-lock.json: 包版本控制文件
```
# 2、项目配置
### 2.1 项目运行，浏览器自动打开
```json
package.json
    "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
    },
```
### 2.2 关闭 eslint 校验工具（不关闭会有各种规范，不按照规范就会报错）

根目录下创建 vue.config.js,进行配置
```js
module.exports = {
  //关闭eslint
  lintOnSave: false
  }
```
### 2.3 src 文件夹配置别名,创建 jsconfig.json，用 @/代替src/，exclude 表示不可以使用该别名的文件
```json
{
    "compilerOptions": {
        "baseUrl": "./",
            "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },

    "exclude": [
        "node_modules",
        "dist"
    ]
 }
 ```
 # 3、 项目路由的分析
- vue-router
- 前端所谓路由：KV键值对
- key: URL (地址栏中的路径)
- value：相应的路由组件
- 注意：项目上中下结构

路由组件：
Home 首页路由组件、Search 路由组件、login组件、Refister注册路由

非路由组件：
Header【 首页、搜索页 】
Footer【 首页、搜索页 】，但是在登录 / 注册页面没有

# 4、完成非路由组件Header与Footer业务
在开发项目的时候:
- 1:书写静态页面 (HTML + CSS)
- 2:拆分组件
- 3:获取服务器的数据动态展示
- 4:完成相应的动态业务逻辑
  
注意 1：创建组件的时候，组件结构 + 组件的样式 + 图片资源


组件页面的样式使用的是 less 样式，浏览器不识别该样式，需要下载相关依赖 ```npm install --save less less-loader@5``` 

如果想让组件识别 less 样式，则在组件中设置 ```<script scoped lang="less">```

## 4.1 使用组件的步骤(非路由组件)
- 创建或者定义
- 引入
- 注册
  
### 清除 vue 页面默认的样式
vue 是单页面开发，我们只需要修改 public 下的 index.html 文件
```<link rel="stylesheet" href="reset.css">```

# 5. 路由组件的搭建
vue-router  

在上面分析的时候，路由组件应该有四个: Home、Search、Login、Register

- components文件夹: 经常放置的非路由组件 (共用全局组件)
- pages/views文件夹: 经常放置路由组件
  
## 5.1 配置路由
项目当中配置的路由一般配置在router文件夹中

## 5.2 总结
路由组件和非路由组件区别：

- 非路由组件放在 components 中，路由组件放在 pages 或 views 中
- 非路由组件通过标签使用，路由组件通过路由使用（在 router 文件夹中进行注册（routes
- 在 main.js 注册完路由，所有的路由和非路由组件身上都会拥有 `$router`、`$route` 属性
- `$router`：一般进行**编程式导航进行路由跳转** 【push/replace】
- `$route`： 一般**获取路由信息**（name path params 等）

## 5.3 路由跳转方式

- 声明式导航 `router-link` 标签 ,可以把 router-link 理解为一个 `a 标签`，它也可以加 class 修饰
- 编程式导航 ：声明式导航能做的编程式都能做，而且还可以处理一些业务  

# 6. footer 组件显示与隐藏

- footer 在登录注册页面是不存在的，所以要隐藏，`v-if` 或者 `v-show`
- 这里使用 v-show，因为 v-if 会**频繁的操作 dom 元素消耗性能**，v-show 只是**通过样式**将元素显示或隐藏
- 配置路由的时候，可以给路由配置`元信息 meta`,
- 在路由的**元信息**中定义 show 属性，用来给 v-show 赋值，判断是否显示 footer 组件
  
# 7. 路由传参
路由跳转有几种方式  
> 声明式导航：router-link务必要有 to 属性)，可以实现路由的跳转

> 编程式导航：利用的是组件实例的$router.push | replace方法，可以实现路由的跳转，（可以书写一些自己的业务）

## 7.1 query、params

- query、params两个属性可以传递参数  
- `query` 参数：**不属于路径当中的一部分**，类似于 get 请求，地址栏表现为 `/search?k1=v1&k2=v2`   
  query 参数对应的路由信息 `path: "/search"`  

- `params` 参数：**属于路径当中的一部分**，需要注意，在配置路由的时候，***需要占位*** ,地址栏表现为 `/search/v1/v2`  
params 参数对应的路由信息要修改为 `path: "/search/:keyword"` 这里的 `/:keyword` 就是一个 **params 参数的占位符**
    
## 7.2 传参方法

- 字符串形式
```js
this.$router.push("/search/"+this.params传参+"?k="+this.query传参)
```
- 模板字符串
```js
this.router.push("/search/+{this.params传参}?k=${this.query传参}")
```
**注意：** 上面字符串的传参方法可以看出 params 参数和 `'/' `结合，query 参数和 `？`结合;  

`http://localhost:8080/#/search/asd?keyword=asd`  

上面 url 中 asd为 params 的值,`keyword=asd` 为 query 传递的值

- 对象（常用）  
  
```js
this.$router.push({name:"路由名字",params:{传参},query:{传参})
``` 
  以**对象方式**传参时，如果我们传参中使用了 params，只能使用name，不能使用 path，如果只是使用 query 传参，可以使用path

# 8. 多次执行相同的push问题
- 问题描述  
  编程式路由重复点击(参数不变),多次执行会抛出NavigationDuplicated警告报错

- 问题分析，为什么会报错？  
  Vue router3.1之后，`$router.push()`返回 Promise,返回的promise **没有设置**失败的**回调**，没有对错误进行处理

- 解决办法  
  1.对每个 `router.push()` 进行错误捕获
  ```
  router.push('xxxx').catch(err => {err})
  ```
  push方法还可以传入成功和失败的回调
  ```js
    this.$router.push({
		name:'search', // 路由记得命名
		params:{keyword:this.keyword},
		query:{keyword:this.keyword.toUpperCase()}
    },()=>{},(err)=>{if(如果是NavigationDuplicated错误)console.log(err)})

  ```


- 方法：
```js
this.$router.push({name:'Search',params:{keyword:".."||undefined}},()=>{},()=>{}) 
```
后面两项分别代表 **执行成功和失败的回调函数**。  
但是这种写法治标不治本，将来在别的组件中 `push|replace`,编程式导航还是会有类似错误。  
- push 是 `VueRouter.prototype` 的一个方法，在 router 中的 `index` **重写该方法即可**

- 2.重写 push() 方法  
  ① 先保存 VueRouter 原型上的 push 方法  
  ② 重写 push|repalce  
  
```js
// 1、先把 VueRouter 原型对象的 push，保存一份
let originPush = VueRouter.prototype.push;

// 2、重写 push|replace
// 第一个参数：告诉原来的 push，跳转的目标位置和传递了哪些参数
VueRouter.prototype.push = function (location,resolve,reject){
    if(resolve && reject){
        originPush.call(this,location,resolve,reject)
    }else{
        originPush.call(this,location,() => {},() => {})
    }
}
```

# 9. 三级联动
我们的三级联动组件是全局组件，全局的配置都需要在 main.js 中配置

```js
//将三级联动组件注册为全局组件
import TypeNav from '@/pages/Home/TypeNav';
//第一个参数：全局组件名字，第二个参数：全局组件
Vue.component(TypeNav.name,TypeNav);
```
在 Home 组件中使用该全局组件

```Vue
<template>
<div>
<!--  三级联动全局组件已经注册为全局组件，因此不需要引入-->
  <TypeNav/>
</div>
</template>
```
全局组件可以在任一页面中直接使用，不需要导入声明

